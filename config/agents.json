{
  "askdb": {
    "class": "CustomAgent",
    "description": "agent to ask questions to postgres db directly.",
    "model_type": "bedrock",
    "model_name": "anthropic.claude-3-7-sonnet-20250219-v1:0",
    "system_prompt": "\nYou are AskDB, an intelligent agent with access to a tool for executing PostgreSQL database queries. Your role is to answer user questions about the database in clear, natural language.\n\nAdditional Instructions:\n- If you find new information during a conversation (such as new facts about the database, schema, or data), update your memory with that information so you can answer similar queries more quickly in the future.\n- When a conversation starts, load your memory with details about the database and its schema to be aware of the structure and content before answering questions.\n\nInstructions:\n\n- Only allow and execute read-only queries (e.g., SELECT). Do NOT allow or execute any queries that edit, delete, or modify the database (such as UPDATE, DELETE, INSERT, ALTER, DROP, etc.).\n- Never fetch or return the entire database or very large datasets in a single response. If a query could return a large amount of data, use intelligent pagination and inform the user about the data size and how to request more if needed.\n- Always prioritize concise, relevant answers. Summarize or aggregate results when possible to avoid context overflow.\n- If a user requests a restricted action (edit, delete, modify), politely refuse and explain that only read-only access is permitted.\n- When answering, provide clear explanations in natural language. Do NOT show SQL queries unless the user explicitly asks for them (e.g., \"show SQL\" or \"give me the query\").\n- Do not ask users for query confirmation. Always infer the required details and generate the answer directly.\n- Provide answers in clear, natural language unless the user explicitly requests otherwise.\n\n\nYour goal is to help users explore and understand the database.\n\nYour responses should help users explore and understand bonus policies and awarded bonuses, while strictly following the above rules.",
    "tools": [
      "postgres_query",
      "read_memory",
      "append_memory"
    ],
    "parallel_tools": true,
    "max_parallel_tools": 3,
    "memory": "[2025-08-17 22:58:39] The important tables in DB are: account, account_domain_event, account_transfer_record, active_users, affiliate, affiliate_account, affiliate_campaign, affiliate_comm_history, affiliate_entry, affiliate_policy, assets, banking_transaction, banners, bonus, bonus_account, bonus_policy, campaign_entry, casino_categories, casino_games, casino_games_old, casino_providers, catalog_domain_event, comm_entry_entity, commission_ledger, customer_order, customer_order_old, daily_entry, daily_house_pl, databasechangelog, databasechangeloglock, deposit_turnover, exposure_log, gap_casino_games, group_admin_entity, ha_pl_entity, house_settings, integrator, kpi_entity, login_device_stats, market_exposure, market_exposure_old, notification, order_domain_event, order_limit, order_setting, pg_stat_statements, pg_stat_statements_info, pl, redemption, sap_pending_bets, sb_casino_games, sb_casino_providers, shedlock, sports_book, sports_book_aliases, sports_book_level_games, system_bet_locked_user, turnover_entry, user_activity, user_commission_history, user_gambling_limit, user_ip_config, user_management, user_notification, user_profile, user_self_exclusion, user_stats, wallet, wallet_domain_event, wallet_last_transaction, wallet_transaction, wallet_transaction_log_old, wallet_transaction_old, whitelabel_config, whitelabel_domain_aliases, whitelabel_skins, wl_sdm_info.\n\n[2025-08-17 23:05:27] Database Schema Information:\n\n1. bonus table:\n- id (bigint, NOT NULL): Primary identifier for bonuses\n- account_id (bigint, NOT NULL): User account ID\n- account_path (varchar, NOT NULL): Hierarchical path of the account\n- approval_required (boolean): Whether bonus needs approval\n- award_amount (double precision, NOT NULL): Amount awarded\n- award_date (timestamp with timezone, NOT NULL): When bonus was awarded\n- award_freq (varchar): Frequency of award\n- bonus_type (varchar, NOT NULL): Type of bonus\n- bonus_policy_id (bigint): Reference to bonus_policy table\n- bonus_status (varchar, NOT NULL): Status of the bonus (e.g., active, redeemed, expired)\n- data (bytea): Additional data in binary format\n- expiry_date (timestamp with timezone): When bonus expires\n- house_id (bigint): Reference to house/operator\n- installments (integer): Number of installments for the bonus\n- installments_given (integer): Number of installments already given\n- notes (varchar): Additional notes\n- pl (numeric, NOT NULL): Profit/Loss\n- redeem_amount (double precision, NOT NULL): Amount redeemed\n- redeem_date (timestamp with timezone): When bonus was redeemed\n- referee (bigint): Reference to referred user\n- referral_role (integer): Role in referral\n- referred_by (bigint): User who referred\n- turnover_met (numeric): Turnover requirement met\n- turnover_required (double precision): Turnover requirement\n- turnover_snapshot (double precision): Turnover at time of award\n- user_name (varchar, NOT NULL): Username of bonus recipient\n- version (bigint): Version number\n- pg_transaction_id (bigint): PostgreSQL transaction ID\n- reference_id (varchar): External reference ID\n- parent_id (bigint): Parent bonus ID\n- deposit_amount (numeric): Associated deposit amount\n\n2. bonus_policy table:\n- id (bigint, NOT NULL): Primary identifier\n- approval_required (boolean): Whether bonuses need approval\n- availed_users_count (bigint): Number of users who used this policy\n- award_freq (varchar): Frequency of award\n- banner_ids (varchar): Associated marketing banner IDs\n- bonus_category (varchar, NOT NULL): Category of bonus\n- bonus_purpose (varchar, NOT NULL): Purpose of the bonus\n- bonus_settings (bytea): Settings in binary format\n- create_time (timestamp with timezone, NOT NULL): When policy was created\n- created_by (varchar): Who created the policy\n- description (varchar): Policy description\n- end_date (timestamp with timezone, NOT NULL): When policy ends\n- expiry_duration_secs (bigint): How long bonuses last in seconds\n- is_active (boolean): Whether policy is active\n- limit_per_user (integer): Limit of bonuses per user\n- max_users (bigint): Maximum users allowed\n- min_amount (double precision): Minimum amount required\n- name (varchar): Policy name\n- sports_book (varchar, NOT NULL): Associated sportsbook\n- start_date (timestamp with timezone, NOT NULL): When policy starts\n- updated_by (varchar): Who last updated the policy\n- version (bigint): Version number\n- coupon_code (varchar): Associated coupon code\n- bonus_policy_status (varchar): Status of the policy\n\n3. customer_order table:\n- order_id (bigint, NOT NULL): Primary identifier\n- account_id (bigint): User account ID\n- account_path (varchar): Hierarchical path of the account\n- alert_status (integer): Alert status\n- cancelled_stake (numeric): Cancelled stake amount\n- category_type (integer): Category type\n- competition_id (varchar): Competition identifier\n- competition_name (varchar): Competition name\n- event_date (timestamp with timezone): Date of the event\n- event_id (varchar): Event identifier\n- event_name (varchar): Event name\n- hold_percentage (integer): Hold percentage\n- house_id (bigint): House/operator ID\n- ip (varchar): IP address\n- market_id (varchar): Market identifier\n- market_name (varchar): Market name\n- market_type (integer): Type of market\n- matched_odd (numeric): Matched odds\n- matched_stake (numeric): Matched stake amount\n- odd_after (numeric): Odds after\n- odd_before (numeric): Odds before\n- order_type (integer): Type of order\n- outcome_id (varchar): Outcome identifier\n- outcome_name (varchar): Outcome name\n- placed_odd (numeric): Placed odds\n- placed_stake (numeric): Placed stake amount\n- placed_time (timestamp with timezone, NOT NULL): When order was placed\n- provider_correlation_id (varchar): Provider correlation ID\n- provider_id (varchar): Provider identifier\n- provider_name (varchar): Provider name\n- reference_ids (text, NOT NULL): Reference IDs\n- remaining_stake (numeric): Remaining stake\n- remarks (text): Additional remarks\n- returns (numeric): Returns amount\n- session_price (numeric): Session price\n- sport_id (varchar): Sport identifier\n- sport_name (varchar): Sport name\n- status (integer): Order status\n- sub_status (integer): Order sub-status\n- update_time (timestamp with timezone): Last update time\n- username (varchar): Username\n- voided_by (varchar): Who voided the order\n- has_commission (boolean): Whether order has commission\n- bonus_redeemed (numeric): Bonus amount redeemed\n- initiated_time (timestamp with timezone): When order was initiated\n- market_category (varchar): Market category\n\n4. kpi_entity table:\n- id (bigint, NOT NULL): Primary identifier\n- account_path (varchar, NOT NULL): Hierarchical path of the account\n- category (varchar, NOT NULL): KPI category\n- create_time (timestamp without timezone, NOT NULL): When KPI was created\n- reference_id (bigint): Reference ID\n- sports_book (varchar): Associated sportsbook\n- sub_category (varchar, NOT NULL): KPI sub-category\n- value (double precision, NOT NULL): KPI value\n- account_mode (integer): Account mode\n- username (varchar): Username\n- account_id (bigint): Account ID\n\n5. turnover_entry table:\n- id (bigint, NOT NULL): Primary identifier\n- account_id (bigint, NOT NULL): User account ID\n- account_path (varchar, NOT NULL): Hierarchical path of the account\n- amount (numeric): Amount\n- bets_count (integer): Number of bets\n- category_type (integer): Category type\n- competition_id (varchar): Competition identifier\n- create_time (timestamp with timezone): Creation time\n- event_date (timestamp with timezone): Event date\n- event_id (varchar): Event identifier\n- event_name (varchar): Event name\n- house_id (bigint): House/operator ID\n- market_id (varchar): Market identifier\n- market_name (varchar): Market name\n- market_type (varchar): Market type\n- sport_id (varchar): Sport identifier\n- transaction_type (varchar): Type of transaction\n- turnover_after (numeric): Turnover after transaction\n- username (varchar, NOT NULL): Username\n- version (bigint): Version number\n\n[2025-08-17 23:09:53] Additional information about kpi_entity table:\n\n1. Purpose: Stores KPI events for accounts across different sportsbook white-labels, tracking activities like deposits, withdrawals, sign-ups, and refunds with associated metadata for reporting and analytics.\n\n2. Enum values:\n   - KpiCategory: DEPOSIT, WITHDRAW, SIGNUP, REFUND\n   - KpiSubCategory: FIRST_DEPOSIT, OTHERS\n\n3. Important relationships:\n   - reference_id: Links to related transaction or account records\n   - sports_book: Links KPIs to white-label sportsbook brands for multi-brand analytics\n\n4. Usage patterns:\n   - DEPOSIT KPIs with FIRST_DEPOSIT sub-category are used for first deposit bonuses or onboarding metrics\n   - WITHDRAW and REFUND categories always have a monetary value in the value field\n   - SIGNUP KPIs have the new account's ID in reference_id and typically a zero value\n   - create_time is critical for time-based analytics like daily active users or revenue reports\n\n[2025-08-17 23:12:06] Turnover Entry Table (turnover_entry):\n- Purpose: Records user turnover when bets/markets are settled across Casino, Premium, Sportsbook, and Sports categories\n- Used by reporting, VIP, and bonus redemption flows\n- OrderCategory enum values: SPORTS, PREMIUM, SPORTS_BOOK, CASINO\n- First place turnover is recorded after settlement\n- Turnover data flows to bonus processing:\n  1. Settlement → Insert into turnover_entry\n  2. Select Eligible Bonus (FIFO by award time)\n  3. Apply Turnover to a Single Bonus (increasing bonus.turnover_met)\n  4. When turnover_met reaches turnover_required, bonus is REDEEMED\n- Turnover Definition:\n  - Casino/Premium: Stake amount of settled bets\n  - Sports/Sportsbook: Net market risk at market-level settlement\n  - Exclusions: voided/canceled bets or settlements flagged as ineligible\n\nRelationship between kpi_entity and turnover_entry tables:\n- kpi_entity tracks business KPIs (DEPOSIT, WITHDRAW, SIGNUP, REFUND)\n- turnover_entry tracks wagering/settlement turnover events\n- They can be related by user using:\n  - account_id (preferred key for exact matching)\n  - account_path (useful for hierarchy rollups)\n- Tenant scoping: kpi_entity.sports_book vs turnover_entry.house_id\n- Cardinality: One user has many KPI events and many turnover entries\n\nBonus processing flow:\n- Turnover entries are used to progress active bonuses by increasing bonus.turnover_met\n- FIFO rule applies to bonus processing (oldest bonus first)\n- When turnover_met reaches turnover_required, bonus status changes to REDEEMED\n- Required turnover is typically: award_amount × multiplier\n\n[2025-08-17 23:15:47] Customer Order Table (customer_order):\n1. Purpose: Records all betting orders across different categories (Sports, Casino, Premium, Sportsbook).\n2. Key columns:\n   - order_id: Primary key\n   - account_id: User identifier\n   - category_type: Enum (0=Sports, 1=Premium, 2=Sportsbook, 4=Casino)\n   - matched_stake: Actual amount bet\n   - returns: Total payout to player\n   - status: Order status (Won, Lost, Open, Voided, etc.)\n\n3. Category-specific information:\n   - Casino (category_type=4): sport_id=event_id (game ID), market_type=4\n   - Sports (category_type=0): Uses lowercase sport names, market_type=0 (MATCH_ODDS)\n   - Premium (category_type=1): Uses Sportradar style IDs, market_type=3 (PREMIUM)\n   - Sportsbook (category_type=2): Similar to Premium but for virtual/real sports, market_type=3\n\n4. Important calculations:\n   - Profit calculation: SUM(matched_stake - returns) [positive = house profit, negative = player profit]\n   - Only settled bets should be used for P&L calculation\n\n5. Common query patterns:\n   - Casino game profitability: Filter by category_type=4, specific event_id, calculate matched_stake-returns\n   - User activity: Count distinct account_id for specific games/events\n   - Popular games: Group by event_id/event_name, count distinct account_id\n   - Sports summary: Group by sport_id, calculate P&L\n\n6. Relationships:\n   - Links to turnover_entry for tracking wagering volume\n   - Can be used with kpi_entity to analyze deposits and betting patterns\n\n7. Important fields for analytics:\n   - update_time: For time-based filtering\n   - event_id/event_name: For game/match identification\n   - provider_id/provider_name: For provider analysis"
  },
  "askdb-pro": {
    "class": "CustomAgent",
    "description": "Advanced version of AskDB agent with enhanced capabilities. it can perform more complex queries and handle larger datasets.",
    "model_type": "bedrock",
    "model_name": "anthropic.claude-3-7-sonnet-20250219-v1:0",
    "system_prompt": "\nYou are AskDB Pro, an advanced intelligent agent with access to AskDB for executing PostgreSQL queries.\n\nYour role is to deliver business-level insights and actionable recommendations based on database information. You can orchestrate sub-queries using the AskDB agent, especially when handling large datasets or complex analysis.\n\nInstructions:\n\n- You may execute both read-only and write queries, but always prioritize data integrity and security.\n- For write queries, you can explicitly say no to modify any queries.\n- When a user request involves large data or complex analysis, break the task into smaller sub-queries and delegate them to the AskDB agent. Aggregate and synthesize the results to provide clear, high-level business insights.\n- Always provide business value: interpret data, highlight trends, identify opportunities, and suggest next steps or further analysis that could help the user achieve their goals.\n- Proactively recommend what the user can do next, based on the information provided and business context.\n- Provide clear explanations in natural language. Do NOT show SQL queries unless the user explicitly requests them (e.g., \"show SQL\" or \"give me the query\").\n- Do not ask users for query confirmation. Infer required details and generate the answer directly.\n- Always answer in clear, natural language unless the user requests otherwise.\n- If a query is complex, you may execute it in parts and in parallel by calling the AskDB agent multiple times with sub-queries.\n\nYour goal is to help users explore and understand the database, extract business value, and guide them toward actionable decisions while maintaining its integrity.\n",
    "tools": [
      "askdb",
      "read_memory",
      "append_memory"
    ],
    "parallel_tools": true,
    "max_parallel_tools": 4,
    "memory": ""
  }
}